#def the method that searches the array, give it two params: one for the array being processed, one for the item we are searching for
# since we are searching without the use of .each we will need a while loop
# create a variable that represents each time the item loop goes over an item in the array.
# we can use an index value to represent each turn of the loop, i
# while the arr.length (the number of items in the array that we are going through ) is less than the number of times we have gone through it ( represented by index i ) if the VALUE at index i is equal to the item we are searching for (search_num) then returns the index number.
# If at no index value does the number searched for match the array item then method returns nil


Release 0
def search_array(arr, int)
    i = 0
    while i < arr.length
        if arr[i] == int
            return i
        else
          puts NIL
        end
    i += 1
end
end

# The concept of Fibonacci numbers is pretty simple: you start off with a 0 and a 1, and keep adding numbers onto the list by adding the previous two. With that in mind, an array of the first six Fibonacci terms would be [0,1,1,2,3,5]. Each number in the array is the sum of the previous two numbers, except for the 0 and the 1, which we started out with.

# (Note that some Fibonacci sequences start out with two 1s instead. Don't let that confuse you.)

# DO THE THING
# Add a method to your file that takes a number of Fibonacci terms to generate and returns an array of the terms. For example, fib(6) would return [0,1,1,2,3,5]. Your method should work for a large number of terms. To verify your work: the last number in the array generated by fib(100) will be 218922995834555169026. (How can you verify this without having to compare this huge number manually? Be smart with your driver code!)

#Create an array that already has 0 and 1
#the method will take an integer that represents the number of times I want to run the fib process. We will call that integer int
#the process will involve 3 variable:
# a = your starting number, which will have a starting value 1 in every sequence
# b = a + 1 this is the second number you will be adding to a, which is always equal to a + 1
# c = a + b which is the resulting number
# as the last step in the sequence c will become the new starting value so a = c
# the loop runs again until the number of loop runs equals the end number that you are running the fib process on the integer variable int

#Revised pseudo code:
#the method will contain a while loop which starts with an index of 0 and a an array containing 0 and 1
  #while the index value is smaller than the number of times we want the
  #fib process to run
  #the code will add the value at the last index which expressed with arr[i] to the value at the current index which is arr[i + 1] . (Remember that we are not adding together index values, we are adding together the values of the number inside of those index values)
  # We want the resulting number to be added to the end of the array
  # Voila


def fib(int)
  arr = [0, 1]
  i = 0
  while i < int

  #F (n-1) + F_n = F(n + 1)
arr << arr[i] + arr[i + 1]
#= arr[i + 2]

# The code attempt below failed because a was hard coded to a value of 1 and returned to that value every time the loop ran so the output repeated the same answer int number of times.
  # a = 1
  # b = a + 1
  # c = a + b
  # arr << c
  #a = c this assignment is happening inside a while loop. But its being reassigned back 1 at the start of the loop. I need a variable instead of hard coding it in..
  i += 1
end
  p arr
end


fib(4)

# Release 2 - Creating a sorting algorithm

#First version
arr = [12, 5, 1, 7]

i = 1
#while i < arr.length
  if arr[i] < arr[i - 1]
    moved_num = arr[i]
    #p arr[i - 1]

  #end
    arr.unshift(moved_num)
    #arr.insert(i - 1, moved_num)

    arr.delete(arr[i+1])
    p arr
    #i += 1
end
end
#       #variable can be used for first arguement here but dont make it be the value at that index as expressed by a number in brackets, just the actual integer of the index value or a variable
#
#     #its trying to turn an array into an integer for some reason...
#     #move arr[i] back one index position
#   i += 1
# end
# p arr
# end

#second version
i = 1

arr = [12, 5, 1, 7]
i = 1
until i == arr.length * 2
  arr.each do |item|
    if arr[i] < arr[i - 1]
      move_num = arr[i]
      p move_num
      arr.unshift(move_num)
      #p arr
      i += 1
    end
  end
end

